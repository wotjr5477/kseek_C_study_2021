# C_Programing / Linux_Ububtu


## Part1. C 프로그래밍 기초

리눅스(Linux) : 무료로 제공되는 운영체제

장점 : 뛰어난 안정성, 다중사용자, 다중작업의 지원, 강력한 네트워킹, 유닉스와 유사한 환경제공, 무료

C언어 : 유닉스의 언어, 비트나 바이트 처리, 포인터에 의한 주소처리(연결리스트)가능

(C 컴파일러 : gcc, C 언어 디버깅 툴 : gdb, C 언어 컴파일 자동화 툴 : make)



### <리눅스에서 C 프로그램 실습>

디렉토리 만드는 명령어 : mkdir

디렉토리로 이동 : cd

C 언어로 된 프로그램 작성 : vi 편집기

컴퓨터가 이해할 수 있도록 실행파일로 변환 : gcc

입력모드 : i

명령모드 : Esc

저장 후 종료 : :wq

파일 보여줌 : ls

./ 실행파일 : 현재 디렉토리가 path로 설정되지 않아 명령어 찾을 수 없기 때문



### <기본 프로그램>

#include <stdio.h> : 기본적인 입출력함수로 정보를 포함하는 기능, stdio.h파일에 있는 정보 사용 가능, #으로 시작하는 부분( =전처리기 지시자)

main() : C 프로그램에 반드시 필요, 없으면 컴파일 불가능

\n : 커서를 다음 줄로 옮김



### <상수를 이용한 프로그램>

상수 : 프로그램이 실행되는 동안 변하지 않는 값

수치상수 (고정소수점 상수, 부동소수점 상수) : ‘& + 한 문자’가 n개 있다면 인수도 n개

문자상수 : 작은 따옴표, 대응되는 정수값이 있음

문자열상수 : 큰 따옴표, 마지막임을 의미하는 NULL(‘\0’)문자가 포함, +1바이트 공간 필요

확장문자열 : ‘\ + 하나의 문자’

기호상수 : 하나의 의미있는 이름이나 기호로 표시, 내용변경불가능, 원주율 : 3.14 -> PI

                #define으로 정의해야 사용가능
                
열거형 상수 : enum이라는 예약어로 정의. 상수들의 집합



<변수를 이용한 프로그램>i

간단한 수치계산 프로그램에서도 연산된 결과를 저장할 공간, 메모리에 생성됨

데이터형(저장될 값의 형태를 결정) 변수이름; / 데이터형 변수이름 = 값;

고정소수점 : 정수(int, short int, long int, unsigned int)

                                바이트 폭은 해당 변수에 배정되는 메모리 크기 - sizeof연산자

‘오버플로’현상 : 표현할 수 없는 값을 지정해 발생, 저장할 공간이 부족한 관계로 엉뚱한 결과 출력

부동소수점 : 실수(float, double, long double)

문자형 : 하나의 문자를 저장하기 위한 데이터형, 대응되는 정수값있음

문자열형 : char형 배열(str)을 이용해 선언, 마지막은 ‘\0’

                strcpy(s,t) : 문자열을 배열 변수에 한번에 저장, 문자열 t를 s에 복사

typedof 기존의데이터형 새로운데이터형 이름; = 새로운 데이터형 이름을 만들 수 있음

const = 값을 변경할 수 없는 변수 지정 (선언할 때만 가능)



<함수를 이용한 프로그램>

main외에도 func함수를 사용

함수정의 -> 함수호출 / 함수선언 -> 함수호출 -> 함수정의



함수유형1. 반환하는값 X, 매개변수 X



함수유형2. 반환하는값 O, 매개변수 X

함수 이름 앞에 반환값의 데이터형 명시 -> return에 의해 값이 반환



함수유형3. 반환하는값 X, 매개변수 O

매개변수(실매개변수(호출하는쪽), 형식매개변수(정의하는쪽))



함수유형4. 반환하는값 O, 매개변수 O

( =add함수)



- void명시 : 함수는 값을 반환하지 않는다



<연산자>

산술연산자 : 수치계산(덧셈, 뺄셈, 곱셈, 나눗셈), 

                    증가연산자(++), 감소연산자(--) -> 위치중요

관계연산자 : 크기관계평가해 참/거짓

대입연산자 : 변수값변경(=), 복합대입연산자(+=), 계승(Factorial) = n! 

논리연산자 : 한 가지 이상의 조건을 동시에 요구 시, &&(and), ||(or), !(not)

비트연산자 : 비트단위로 다룸(int, char, long) / 2개의 문자 -> 비트연산 -> 2진코드형태

시프트연산자 : 정수형데이터의 비트를 이동, <<, >>

                       부호가 없는 unsigned형은 좌측비트로 0이 들어옴

                       부호가 있는 int형은 가장좌측비트의 부호가 들어옴

콤마연산자 : 여러수식을 하나로, 가장 오른쪽 수식의 실행결과값을 따름

조건연산자 : 조건을 만족하는지 여부에 따라 지정된 수식실행, 수식1 ? 수식2 : 수식3

sizeof연산자 : 데이터형의 크기를 알기 위해

                      sizeof (데이터형) / sizeof (변수)

                      (malloc, calloc함수는 임의의 데이터형의 크기만큼 메모리 동적 할당)

형 변환과 캐스트연산자 : 작은 크기의 데이터형을 큰데이터형으로 자동변환해 연산

                                       임의로 형 변환 -> (형이름) 수식



<제어문>

실행순서를 변경

if문(분기문) : 조건에 대해 두 가지 경우를 처리, 조건이 거짓인 경우 else를 이용

switch문 : 다양한 경우의 처리, 

                            수식값과 case다음의 상수식과 일치여부, 없으면 default(생략가능)

                            상수식에 포함된 문장만 실행 = break;

while문 : 유사한 문장이 반복되어 실행, 시작부분에서 종료조건 검사

                          조건이 참이면 그 문장 실행 -> while문으로 다시가서 조건식 평가 ->

                          참이면 또 문장 실행 -> 거짓일 때까지 반복실행

                          while의 반복문을 빠져나오려면 while(1)쓰고 밑에 break적기

for문 : 조건식이 참인 경우 특정 부분의 명령문 반복수행, 시작부분에서 종료조건 검사

          for(초기식;조건식;변환식)

          참 : 문장 실행 -> 변환식 계산 -> 다시 조건식 평가

          거짓 : 문장 실행하지 않음 -> 종료

                     수식은 생략이 가능하지만 세키롤론은 생략불가능

                     for문 -> while문으로 표현 가능

                     빠져나오려면 break이용

do-while문 : 문장을 우선 실행, 반복문 마지막에서 종료 조건 검사(적어도 한 번은 실행)

                    while(조건식); 이렇게 뒤에 세미콜론이 붙음

**반복문비교(for문, while문, do-while문)

break문 : 강제로 벗어나게 하는데 사용

continue문 : 현재 반복을 멈추고 다음 반복을 하게 함

                                반복문에서만 사용 가능(switch에서 사용불가능)



<배열과 포인터>

-배열 : 데이터 구조의 한 형식, 동일한 데이터형의 요소가 같은 크기로 순서대로 나열되어 있는 집합

          C언어에서는 첨자가 0에서부터 시작, 보통 7개([7])까지 사용 -> 7차원

1차원배열 : 첨자를 하나만 사용, 같은 데이터형 변수가 일직선으로 이루어짐

2차원배열 : 첨자를 두 개 사용, 같은 데이터형 변수가 행과 열로 이루어 짐(행렬)

3차원배열 : 첨자를 세 개 사용, 같은 데이터형 변수가 행, 열, 면으로 이루어 짐



-포인터 : 메모리의 주소를 저장하는 변수

             각 부분을 구분하기 위해 주소가 부여되어있으므로 변수에는 대응되는 주소가 있음

             &변수 = 변수의 주소 / *변수 = 포인터변수 선언



-포인터와 배열

-포인터로 문자열 다루기 : char형 포인터를 이용해 문자열 다루기, 마지막은 NULL값



<함수>

함수 : 특정한 작업을 수행하도록 설계된 독립적인 프로그램, 여러 함수 -> 하나의 프로그램

         대표적인 함수 = main함수

         라이브러리 함수 / 사용자정의 함수

함수선언 : 데이터형 함수이름 (매개변수들); / 매개변수 = 데이터형 변수이름

                            main함수 전이나 함수가 호출되기 전에 이루어져야 함

함수정의 : 실행할 내용이 실제로 존재하는 부분,

                함수 이름 앞의 데이터형은 반환하는 값의 데이터형

                return 수식; : 수식이 없다는 건 반환값이 없고 실행만 종료시킨다는 뜻

                반환값이 없을 시 void 명시

함수호출 : 함수 정의 부분이 실행되도록 하는 명령어

                            함수이름 (매개변수들); / return형은 기재하지 않음



함수 간 데이터 전달 기법 => ‘매개변수’ 사용

값에 의한 전달 : 값만 보내 매개변수에 저장시켜 동작

                                     형식매개변수 값 변함 -> 실매개변수 값 변함 X

주소에 의한 전달 : 변수가 존재하는 메모리 주소를 전달

                            형식매개변수 값 변함 -> 실매개변수 값 변함 O



기억클래스 : 메모리의 어느 위치를 어떻게 확보하는지 결정하는 것

                    기억클래스 데이터형 변수(함수)이름

자동변수(지역변수) : 함수 안에서 정의

                                함수 실행 -> 메모리에 변수 생성 / 함수 실행 종료 -> 사라짐 

                                 auto 데이터형 변수이름

외부변수 : 변수를 공유하는 대표적인 방법, 함수 밖에서 선언, count변수

                생성된 외부 변수 -> 실행이 종료될 때까지 메모리에서 사라지지 않음

                            외부변수를 재선언해 재사용 가능 => 다른파일에서 선언된 외부변수 이용 가능

레지스터변수 : 변수는 메모리에 생성되지만 레지스터 변수는 레지스터에 생성

                        (레지스터 : CPU내에 있는 일시적으로 정보를 저장하는 기억공간)

                        레지스터가 할당하지 못하는 경우에는 자동변수로 처리됨

정적변수 : 데이터 영역이 기억 영역에 영구적으로 존재 (내부 / 외부)

내부 정적 변수 : 함수 안에서 선언, 함수 빠져 나왔다가 들어와도 이전 값 유지

외부 정적 변수 : 함수 외부에서 선언, 분리 컴파일 시 변수가 선언된 파일 내에서는 참조가 가능하지만 다른 파일에서는 참조 불가능



함수 기억클래스

외부 함수 : 분리컴파일 시 다른 파일에서 참조 가능

                 기억 클래스 자리에 아무것도 없으면 외부 함수

정적 함수 : 분리컴파일 시 다른 파일에서 참조 불가능

                             기억 클래스 자리에 static작성 시 정적함수 의미



재귀호출 : 임의의 함수에서 자기 자신을 호출(피보나치 수열 : fibo(1) = fibo(2) = 1)

                (재귀호출이 종료되는 조건을 설정해줘야 함)



<구조체>

서로 다른 데이터형 변수들을 하나로 묶어 놓은 모임, 정보를 하나로 묶어 관리

구조체형 변수 선언 => struct 태그이름 변수이름1, 변수이름2…

(태그이름 적기 대신 typedef를 입력하고 괄호 닫은 후 이름을 적어줄 수 있다)

구조체변수이름. 멤버이름 -> 멤버로 접근한다

다른 구조체일 경우 복사 불가능, 동일한 구조체일 경우 복사 가능



중첩구조체 : 다른 구조체를 멤버로 사용

                   (구조체에 대한 멤버가 여러개일 경우 그 멤버를 하나로 묶어 다시 하나의 구조체를 생성할 수 있고 하나의 멤버로 이용할 수도 있음)

자기참조구조체 : 자기 자신의 구조체를 가리키는 포인터를 멤버로 하는 구조체

                          같은 유형의 구조체를 서로 연결해 관리하고자 할 때 이용(연결리스트)

                          일반 구조체 변수선언과 달리 필요할 때마다 동적으로 변수를 생성해 동작



<공용체>

공용체 내에 있는 각 멤버가 동일한 기억장소(메모리)를 공유하면서 이를 사용

한 순간에 하나의 멤버만 사용가능

새로운 데이터형의 변수선언 -> union position my; 

(position은 공용체 태그이름 / class와 department의 두 개의 멤버로 구성 -> 둘 중 하나만 사용)

한정된 기억장소를 절약하기 위해 사용



<전처리기>

#로 시작하는 전처리기 지시자



<매크로 정의하기>

#define을 이용해 기호상수로 PI를 정의하는 방법은 PI가 매크로가 된다

매개변수를 사용하는 경우 : #define 매크로이름 치환문자열

                                         #define 매크로이름(매개변수들) 치환문자열

                                        (매크로이름과 매개변수의 목록을 띄우면 안됨!)

매개변수를 사용하지 않는 경우 



#undef : 정의된 매크로를 해제 / #undef 매크로이름



<파일 삽입하기>

<파일 이름> : 해당 파일을 시스템 디렉토리에서 찾음, 시스템에서 미리 만들어 제공

파일 이름” : 해당 파일을 우선 현재 작업하고 있는 디렉토리에서 찾음

                   없을 경우 시스템 디렉토리, 사용자가 직접 작성해 사용

.h : 헤더파일



<조건부 컴파일>

특정 조건이 성립할 때나 성립하지 않을 때 지정한 범위 내에서 문장을 컴파일하거나 무시하고 컴파일 하지 않는 것

#if, #elif, #else, #endif, #indef, #ifndef

#ifdef - 해당 매크로가 정의되어 있으면 실행부분 컴파일

#ifndef - 해당 매크로가 정의되어 있지 않으면 실행부분 컴파일



Part2. 리눅스 C 라이브러리 함수



<문자 판별 함수>

입력받은 값이 어떤 문자에 속하는지 알아야 함

isalpha : 영문자판별함수 (p.171 더 다양한 함수)



<문자 변환 함수>

[toupper : 소문자 -> 대문자] <->  [tolower : 대문자 -> 소문자]



<문자열 연결 함수>

strcat : 연결

strncat : 연결할 문자의 개수를 정할 수 있음 (그중에 한 자리는 NULL값)



<문자열 비교 함수>

(대소문자 구분함)

strcmp : 두 문자열이 같은지, quit면 입력받은 문자열 출력

strncmp : 처음 n개의 문자만 비교



(대소문자 구분안함)

strcasecmp : 두 문자열 비교

strncasecmp : 두 문자열의 n문자 비교



<문자열 복사 함수>

strcpy : 기존내용을 지우고 복사

strncpy : 처음 n개의 문자만 복사

strdup : 문자열에 대한 메모리 영역을 할당하고 포인터를 반환(문자열 배열변수에는 사용불가)



<문자열 길이 계산 함수>

strlen : 문자열의 길이 계산

<문자열 검색 함수>

strchr : 문자열에서 문자가 처음으로 발견된 위치 검색

strrchr : 문자열에서 문자가 마지막으로 발견된 위치 검색

strstr : 문자열에서 문자열을 검색하고 검색에 성공하면 처음 찾은 문자열의 시작 포인터 반환

strspn : 문자열에서 문자집합에 있는 문자로만 이루어진 초기 문자열의 길이를 반환

strcspn : 문자열에서 문자집합에 없는 문자로만 이루어진 초기 문자열의 길이를 반환

strpbrk : 문자열에서 문자집합에 있는 문자 중 일치하는 첫 번째 문자에 대한 포인터 반환



<문자열을 단어로 자르는 함수>

strtok : 문자열에서 지정한 구분자가 나오면 단어로 자르고 단어의 첫 문자에 대한 포인터를 반환



<기본 변환 함수>

정수나 실수 형태의 문자열을 정수나 실수로 변환

atoi : 10진 정수형태의 문자열 -> int형 정수, 부호지정가능, 공백무시, 정수형태의 문자까지만 처리

atol : 10진 정수형태의 문자열 -> long형 정수

atof : 10진 실수형태의 문자열 -> double형 실수, 부호지정가능, 공백무시, 소수점과 지수형태 문자열 처리



<고급 변환 함수>

strtol : 진수형태의 문자열을 long형 정수로 변환, 진법지정 가능(0입력 시, 어떤 진수인지 자동판별)

strtoul : 진수형태의 문자열을 unsigned long형 정수로 변환, 진법지정 가능(“)

strtod : 10진 실수 형태의 문자열을 double형 실수로 변환, 진법지정 불가능

strtof : 10진 실수 형태의 문자열을 float형 실수로 변환, 진법지정 불가능



<동적 메모리 할당과 해제 함수>

동적 메모리 할당 = 프로그램 실행 중에 메모리 할당(malloc, calloc)

malloc : size바이트 크기의 메모리를 동적으로 할당하고 포인터 반환

             반환값 = (void *)형

calloc : 할당을 원하는 요소로 이루어진 배열을 동적으로 할당해 포인터 반환하고 0으로 초기화

free : 할당된 메모리 해제, 사용이 끝난 메모리는 해제가 필요



<메모리 크기 변경 함수>

realloc : 동적 메모리 영역의 크기를 원하는 크기로 변경



<메모리 초기화 함수>

memset : 포인터가 가리키는 메모리 영역의 바이트를 초기화, 할당된 메모리를 NULL로 함



<메모리 영역 복사 함수>

memcpy : 포인터가 가리키는 영역의 바이트를 복사

memmove : 같은 영역에 대한 덮어쓰기가 가능



<메모리 영역 검색과 비교 함수>

memchr : 메모리 영역에서 임의의 문자를 검색

memcmp : s1과 s2가 가리키는 바이트 영역의 내용을 비교해 

                  s1이 크면 양의 정수, 같으면 0, s2가 크면 음의 정수 반환 (strncmp와 유사)



<입출력 함수>

표준입력 : 키보드 / 표준출력 : 모니터

getchar : 표준입력을 통해 한 문자를 입력받음, 입력받을 내용이 없을 시 EOF반환

putchar : 표준출력에 한 문자를 출력함, 오류 발생 시 EOF반환

gets : 표준입력을 통해 한 행의 문자열을 입력 받음, 파일의 끝을 만나면 NULL반환

puts : 표준출력에 한 행의 문자열을 출력함, 개행 O



(입출력장치를 통해서 입출력)

scanf : 표준입력으로부터 서식을 갖춘 데이터를 입력받는 함수, 변환문자열 사용

printf : 데이터를 서식화하여 표준출력을 하는 함수, 변환 문자열 사용

(메모리 주소를 나타내야하기 때문에 &을 붙여야하지만 배열이름은 그 자체가 주소라 붙이면 안됨)



(메모리를 통해 입출력)

sscanf : 문자열을 저장하고 있는 메모리로부터 서식을 갖춘 데이터를 입력받음

sprintf : 데이터를 서식화하여 메모리 영역으로 출력함



<파일 입출력 함수>

fopen(path, mode) : path파일을 mode형태로 열고 파일포인터를 반환, 오류면 NULL반환

fclose : 사용이 끝난 파일을 닫아주는 함수, stream은 fopen이 반환한 파일포인터, 오류면 EOF반환

fgetc : 파일(stream)을 통해 한 문자를 입력받음, 끝이면 EOF반환

fputc : 한 문자를 파일(stream)로 출력, 오류면 EOF반환

fgets : 파일을 통해 한 행의 문자열을 입력받음, 오류면 NULL

fputs : 파일에 한 행의 문자열을 출력, 개행 X, 오류면 EOF



(파일을 통해서 입출력)

fscanf : 파일로부터 서식을 갖춘 데이터를 입력받음, 오류면 -1 

fprintf : 데이터를 서식화하여 파일로 출력, 오류면 -1

fread : 파일로부터 데이터를 입력받아 포인터에 저장 

fwirte : 포인터가 가리키는 문자열에서 데이터를 파일로 출력

ungetc : 파일로부터 읽은 문자를 파일로 되돌림



<기타 입출력 함수>

feof : 파일의 끝인지를 검사

ferror : 파일의 오류를 검사

clearerr : 파일 끝 정보와 오류정보를 초기화

ftell : 파일에 대한 현재 읽기/쓰기 포인터 값을 변환, 오류면 -1반환

rewind : 이 포인터를 처음으로 되돌림, 첫 번째는 0

fseek : 읽기/쓰기 포인터를 임의의 위치로 설정하는 것, 포인터를 whence를 기준으로 이동

            whence(SEEK_SET(시작), SEEK_CUR(현재), SEEK_END(끝)) 



<수학함수>

abs : int형 데이터의 절대값 - <stdio.h>

labs : long형 데이터의 절대값 -<stdio.h>

fabs : double형 데이터의 절대값 - <math.h>

div : int형 나눗셈의 몫과 나머지 -> div_t형으로 반환

ldiv : long int형 나눗셈의 몫과 나머지 -> ldiv_t형으로 반환

fmod : double형 나눗셈의 나머지 반환

ceil : double형 데이터의 소수점 이하를 올림 - <math.h>

floor : double형 데이터의 소수점 이하 버림 - <math.h>

modf : double형 데이터를 정수부와 소수부로 나눔 - <math.h>

rand : 0과 RAND_MAX사이의 난수를 생성

srand : rand를 초기화해 seed(초기값)에 따라 난수 달라짐, rand의 seed값 정의

(실행할 때 마다 다른 난수가 발생하게 하려면 seed값이 바뀌면 되므로 time함수를 둠)

pow : 거듭제곱을 구함

sqrt : 제곱근을 구함 (x는 음이아닌 double형 데이터)



<선형탐색(순차탐색)함수>

주어진 테이블에서 특정 값을 가진 데이터를 찾기위해 테이블의 처음부터 순차적으로 비교하면서 찾는 방법

파일이 정렬되어있지 않아도 되지만 최악의 경우엔 처음부터 끝까지 탐색해야 할 수도

lsearch :테이블에서 찾고자하는 데이터를 탐색해 데이터를 찾지못하면 테이블 뒤에 데이터를 추가

lfind : 테이블에서 찾고자하는 데이터를 탐색해 데이터를 찾지못하면 NULL반환



<이진탐색함수>

테이블을 이분화하여 효율성 증대

삽입과 삭제가 많은 테이블에서는 정렬을 여러 번 수행해야하는 단점

bsearch : 정렬된 테이블에서 key데이터를 이진탐색하고 못찾으면 NULL반환

(반드시 정렬되어야 이진탐색가능)



<이진트리>

새롭게 정렬할 필요없이 데이터끼리 포인터만 연결해주면 매우 효율적

찾고자하는 값이 부모 노드와 같으면 탐색완료, 찾는 값이 부모노드보다 작으면 왼쪽 자식노드, 크면 오른쪽 자식노드로 이동해 탐색

tsearch : 이진트리에서 key데이터를 탐색해 찾지 못하면 이진트리에 key데이터 추가 

tfind : tsearch와 같지만 찾지 못했을 때 NULL반환

tdelete : 이진트리에서 key데이터 삭제

twalk : 이진트리를 방문하는 함수, 노드들의 내용 출력

printtree : 트리의 모든 내용을 출력



<해시테이블관리>

해시테이블 : 컴파일러나 빠른 접근이 필요한 데이터베이스 관리 시스템에서 사용되는 방법

                   데이터의 삽입, 삭제, 탐색이 빠름(key를 이용해 탐색함)

hcreate : 해시테이블 만듦

hsearch : 해시테이블에서 데이터 탐색

hdestroy : 해시테이블 제거(한 순간에 하나만 사용할 수 있기 때문)



< 퀵 정렬 함수(재귀호출사용) >

정렬 : 임의의 순서로 배열된 데이터를 일정한 규칙에 따라 오름차순, 내림차순으로 재배열

          (삽입, 셀, 선택, 퀵)

qsort : 퀵 정렬을 함



<날짜와 시간함수>

time : 시스템의 시간을 출력, 오류면 -1반환 -> 하지만 long형 정수로 나타나 알아보기 어려움

ctime : time_t형의 시간정보를 문자열 형태의 시간정보로 변환

localtime : time_t형 -> struct tm형 지역시간정보로 변환

gmtime :  time_t형 -> struct tm형 세계표준시간으로 변환

mktime : struct tm형 시간정보 -> time_t형

asctime : struct tm형 시간정보 -> 문자열 

strftime : struct tm형 시간정보 -> 서식을 갖춘 시간정보

difftime : 두개의 time_t형 시간으로부터 초 단위 시간차 구함

clock : 프로그램 실행 후 현재까지 경과한 시간 반환(반환값은 초보다 훨씬 짧은 단위)

sleep : 일정시간 정지



Part3. 리눅스 C 프로그래밍 관련 툴



<vi 모드>

입력모드 :글을 입력

명령모드 : 위치이동과 편집기능

최종행모드 : 파일열기, 저장, 문자열검색, 치환



x - 해당 글자 삭제

h - 좌측으로 이동

j - 아래로 이동

k - 위로 이동

l - 우측으로 이동

dd - 현재 행 삭제

dw - 커서 위치에서 단어 끝까지 삭제 

d - 커서 위치에서 행 끝까지 삭제



v - 블록을 지정할 준비 (비주얼모드)

y - 복사

d - 오려두기

p - 커서 앞에  붙여넣기

P - 커서 뒤에 붙여넣기



(블록 지정하지 않고 복사/오려두기)

yy - 현재 행 복사

p - 다음 행에 복사된 내용 붙여넣기

P - 전 행에 복사된 내용 붙여넣기



입력모드(i) VS 수정모드(R)  

삽입모드에서 입력 시 기존의 내용 뒤로 밀림

수정모드에서 입력 시 덮어쓰기



/문자열, ?문자열 : 문자열 검색 (또 다른 검색 - n이나 N)



(파일 다루기)

w 새로지정할 파일이름 : 파일 다루기



<gcc>

컴파일러, 소스파일을 이용해 실행 파일을 만들 때까지 필요한 프로그램을 실행시키는 툴

소스파일 : 고급 언어를 사용해 작성한 프로그램 

실행파일 : 기계가 직접 이해할 수 있는 기계어로 이루어진 프로그램 

cpp(전처리기) -> cc1(컴파일러) -> as(어셈블러) -> ld(링커)



전처리기 : #로 시작하는 부분, 필요한 헤더파일 삽입, 실행 문장의 매크로를 상수로 변환, 디스크에 저장 X

컴파일러 : 어셈블리어로 된 파일 생성, 디스크에 저장 X

어셈블러 : 기계어로 된 오브젝트 파일로 변환

링커 : 라이브러리 함수와 오브젝트 파일을 연결해 실행파일 생성



$ gcc 소스파일이름 : gcc를 이용해 컴파일

ls : 현재 디렉토리에 어떤 파일이 있는지



-o : 소스코드를 컴파일할 때 생성되는 출력파일이름을 지정하는 옵션

-E : 컴파일의 첫 단계인 전처리까지만 실행한 결과

-c : 전처리, 컴파일, 어셈블까지 실행해 오브젝트 파일 생성

(분리컴파일 시, 파일별로 오브젝트 파일을 만들고 나중에 링크하는 것 가능)

(-c를 효율적으로 사용하는 방법 = make)



-l디렉토리 : C 소스가 표준 디렉토리가 아닌 위치에 있는 헤더파일을 가질 때 그 디렉토리의 위치를 지정

라이브러리 : 오브젝트 파일을 모아둔 것, 함수목록도 포함

ar 명령어 : 어떠한 오브젝트 파일로 이루어졌는지 알 수 있음 

(r옵션 : a생성 / t옵션 : .a파일의 내용 표시 / s : 라이브러리 파일 생성)

-l : 표준 라이브러리가 아닌 라이브러리를 지정 (수치연산라이브러리는 -lm붙여주기)

-L : 사용할 라이브러리의 위치를 지정해 줌

      (사용자가 라이브러리를 직접 만들거나 새 라이브러리를 내려 받을 때 사용)

-g : 디버깅 정보를 삽입, 삽입될 디버깅 정보의 양에 따라 -g1, -g2, -g3으로 3단계로 나누어 삽입

(숫자 없이 -g로 옵션을 주면 기본적으로 -g2의 디버깅 정보가 삽입된다)

-ggdb : 디버깅 정보를 삽입, 디버깅 작업을 도와주는 추가 정보가 필요하며 다른 종류의 

디버거에서는 사용 불가능

(디버깅 코드 삽입은 파일의 크기를 크게하므로 최적화 수행 전에 디버깅하는 것이 좋음)

-O : 코드를 최적화시킴, -O1, -O2, -O3이 있고 값이 커질수록 더욱 최적화된 코드가 나옴



<make>

-여러 개의 소스파일과 하나의 실행 파일이 있다고 했을 때 수정할때마다 모두 컴파일하고 링크하지 않고 수정된 파일만 자동으로 알아내 컴파일하고 수정하지 않은 파일에 대해선 기존 오브젝트 파일을 이용하게 해주는 툴

-재컴파일이 필요한지 판단해 프로그램 재구성 작업을 효율적으로 수행하는 역할



(make파일 : 어떤 일을 해야하는지 make에 알려줄 정보를 담고 있는 것, 애플리케이션의 구성방법을 make에 알려주는 텍스트파일)

대상 : make가 궁극적으로 생성하는 것, 일반적으로 오브젝트파일이나 실행 파일, 레이블 이름 (clean : 가짜대상 - 사용자가 원할 때 make가 특정 명령을 실행하도록 하기 위함)

의존성 :대상과 대상을 생성하는 데 필요한 소스파일의 관계, make파일에서는 콜론으로 구분 => 의존관계트리 생성 가능

명령 : 컴파일러 호출, 대상에 의존하는 파일 중 변경된 파일이 있거나 대상이 존재하지 않을 때 실행, 명령 사용 시 반드시 탭으로 시작(스페이스바로 빈칸만들어도 안됨)

touch를 이용해 헤더파일 생성하기 - > 소스파일과 헤더파일을 생성하면 makefile이라는 파일 만들기 -> make실행 -> makefile에 설정된 명령어가 실행(의존관계트리에서 가장 하위대상에 속한 명령부터 실행)



(자동 의존 관계 생성)

makefile수정 -> 가짜대상dep와 gccmakedep를 추가 -> gcc dep해주기 -> makefile내에 각각 파일에 대해 의존성 내용이 자동적으로 추가 됨 (=> gccmakedep유틸리티사용)



(여러 개의 셀 명령 사용)

명령을 하나의 문자열로 적고 각 명령을 구별하기 위해 세미콜론을 적기

한 줄에 적기 어려우면 역슬래시



(명령 실패 무시)

makefile내 명령어 앞에 하이픈(-)을 삽입하면 명령이 실패해도 작업을 계속 진행함(-gcc처럼)

cp : 파일복사명령



<매크로(사용자정의매크로 / 내부매크로)>

$ (매크로이름) : 매크로 정의 / $(매크로 이름:old=new) : 매크로치환

명령을 단순화해 간단한 단어로 표현 가능, 복잡한 make파일 작성 시 유용



make의 매크로(재귀적 확장되는 매크로 / 단순확장되는 매크로)

재귀적으로 확장 : 다른매크로를 포함하면 이 매크로도 같이 확장 -> 무한루프

단순 확장 : 단순히 확장만 되고 매크로 정의 시 등호 앞에 콜론을 삽입

(규칙)

암시적 규칙 : make 내에 미리 정의된 규칙을 이용해 make파일을 단순화시키는 규칙

접미사 규칙 : 소스파일(.c)로부터 오브젝트 파일(.o)을 만드는 과정을 간단히 하는 규칙

                    (.c.o와 같이 자주 사용되는 규칙은 make안에 내장되어 있어 사용가능)

패턴규칙 : 비교적 정확히 처리 규칙을 정해 일어날 수 있는 오류를 방지할 수 있음

                (컴파일 시 대상 파일의 이름에 문자를 추가할 수 있음)



(make 옵션)

-f : 표준파일(GNUmakefile, makefile, Makefile)외의 파일을 실행

-n : make가 실행해야 할 명령을 출력하지만 실행하지는 않음

-W : 특정 파일이 변경된 것처럼 동작하게 함

-s : make가 실행하는 명령을 출력하지 않고 실행(실행명령이 많고 출력이 불필요한 경우 유용)

-r : 모든 내장 규칙 사용불가(따라서 소스파일로부터 오브젝트파일을 생성하는 방법 모름)

-d : make실행 시 디버깅 정보를 출력하도록 할 수 있음, 버그 찾기

-k : make가 명령을 실행하는 데 실패해도 계속 동작하게 함

(하이픈(-)과 차이점 : 하이픈은 그 라인의 명령실패만 무시하지만 -k는 make파일 내 모든 잘못된 명령을 무시)



<gdb로 디버깅하기>

gdb가 설치되어 있는 위치 : cd /usr/bin으로 이동

싷행 => $ gdp 실행파일이름 [코어덤프파일이름] ([코어덤프파일이름]은 생략가능)

종료 => (gdb) quit를 입력

gdb실행 시 디버깅할 실행파일과 소스파일이 같은 디렉토리에 있어야 제대로 동작 => -d옵션

Tab - 명령어 나타남

list 명령어 - 소스파일의 내용 출력(기본 10줄, 보고싶은 부분 지정가능(뒤에 라인번호 적기))

(gdb) list 함수이름 - 임의의 함수 내용 볼 때

run - gdb안에서 프로그램 실행

whatis - 변수의 데이터형 확인 

printf - 변수의 값 보기



(정지점 이용하기)

gdb에서 break를 이용하여 정지점을 설정

프로그램을 디버깅할 때 특정 지점에서 실행을 멈추게 하는 기능

break 문장번호 / break 함수이름 / break 문장번호 또는 함수이름 if 조건(참일때만 조건설정가능)

continue : 정지점으로 프로그램 실행을 멈췄을 때 다시 실행하게 하는 명령

info break : 설정된 정지점 확인

delete : 설정된 정지점 제거



(단계별로 실행하는데 명령어 옆에 숫자를 지정해주면 그 단계만큼 실행)

step : 함수로 들어가서 한 문장씩 추적

next : 함수호출문장을 한 문장으로 인식하게 되어 호출된 함수로 들어가지 않음



Part4. 리눅스가 동작하는 프로그래밍

errno변수 : 오류발생 시 이 변수에 양의 정수로 된 오류번호가 저장됨(0은 오류가 없음)

-> 함수 호출 전 errno변수에 0이라 초기화시켜야 함



(오류발생 시)

포인터 반환하는 fopen함수는 NULL반환

정수값 반환하는 open함수는 -1반환

=> 라이브러리 함수(포인터 반환 / 정수값 반환)

오류관련 정수값을 <errno.h>헤더파일에 124개의 매크로로 정의함

(ENOENT : 오류관련매크로로 ‘그와 같은 파일 또는 디렉토리가 없다’는 의미)



assert : 어떤 조건이 거짓이면 오류 메시지 출력하고 현재상태를 코어덤프한 후 종료

(코어덤프 : 실행 중이던 프로그램에 대한 정보를 디스크에 core라는 이름의 파일로 저장)

-> 하지만 assert함수를 쓰면 컴파일과 실행 시간이 많이 들어 지워야하는데 #include <assert.h> 위에 #define NDEBUG를 입력하면 assert호출 문장을 지우지 않아도 실행되지 않음!)



abort : 프로그램의 현재 상태를 코어 덤프하고 프로그램을 종료

(assert함수가 abort함수를 호출해 종료하는 것이다. 즉 거짓이면 abort함수를 호출하는 것임)

strerror : 오류원인을 정수값이 아니라 설명하는 문자열로 반환(0은 성공으로 오류없음을 의미)

perror : 오류발생 시 시스템이 오류에 맞는 오류 메시지를 자동으로 출력

(perror = strerror + errno)



cat -n test.c (cat은 셀 명령어)

cat : 파일이름을 인자로 받아서 그 내용을 쭉 이어주는 역할 / 파일의 내용을 출력



int main(int argc, char *argv[]) : 명령라인의 인수를 받기(argc-인수의 개수, argv-인수의 내용)

명령라인 인수의 첫 번째 글자가 ‘-’면 옵션으로 간주하고 아니면 인수로 간주함



getopt : 명령 라인 인수를 효율적으로 사용하는 함수, 명령라인 인수를 분석

추가 인자를 받고 싶다면 getopt 함수를 사용할 때 세번째 파라미터에서 문자+콜론(:)으로 추가

옵션목록과 일치하는 옵션이 있으면 옵션을 차례대로 반환 / 모든 옵션 처리하면 -1

옵션목록과 일치하지 않은 옵션을 주면 ?를 반환 / 옵션목록에 인식되지 않은 옵션 k가 저장됨

getopt의 오류 메시지를 출력하지 않으려면 -> opterr=0;을 준다



라인번호가 출력되는 프로그램 구현하기(두 번째 인수부터 출력을 원하는 파일이름 놓기)

getopt : 세 번째 인수를 n으로 두면 -n옵션(라인번호가 함께 출력)처리 가능



환경변수 : 실행중인 모든 프로그램에는 기본적으로 설정된 정보가 있는데 이를 저장한 변수

printenv : 환경변수를 확인하는 셀 명령어

완전한 main함수의 정의 = int main(int argc, char *argv[], char *envp[])

(envp에 환경 변수 정보가 “변수이름 = 변수값”형식으로 저장됨)



environ : 환경변수정보를 저장, 출력

getenv : 지정한 환경변수에 대한 값을 가져오는 함수, 해당변수가 없으면 NULL반환

putenv : 환경 변수의 값을 변경하는 함수, string은 “변수이름=변수값”형식으로 들어가야 함, 이 함수에 의해 설정된 환경변수값은 프로그램이 종료되면 해제되고 실행하기 전 상태로 돌아감

setenv : 변수이름과 변수값을 분리해서 전달(이미 해당변수가 존재할 경우 overwrite값이 0이면 값을 변경하지 않고 1이면 값 변경)

unsetenv : 환경변수 자체를 삭제하는 함수



<사용자와 그룹 정보 알아내기>

사용자 ID(실제 사용자 ID / 유효 사용자 ID)

실제 사용자 ID : 로그인할 때의 사용자로 프로그램을 실행시킨 사용자 ID

유효 사용자 ID : 실행중에 있는 프로그램의 접근권한과 관계된 사용자 ID

(하지만 특수하게 설정된 프로그램의 경우에 실행시킨 사용자와는 상관없이 다른 소유자의 접근 권한을 가지게 되는데 이런 경우에 두 ID는 다르다)



-실행 중에 있는 프로그램의 사용자 ID를 반환하는 함수

getuid : 실제 사용자 ID를 반환

geteuid : 유효 사용자 ID를 반환



-실행 중에 있는 프로그램의 그룹 ID를 반환하는 함수(모든 사용자는 하나 이상의 그룹에 속함)

getgid : 실제 그룹 ID를 반환

getegid : 유효 그룹 ID를 반환



사용자들에 대한 정보 = /etc/passwd

암호에 대한 정보 = /etc/shadow (슈퍼유저만 접근 가능) 



-패스워드파일로부터 사용자에 대한 정보를 가지고 오는 함수

getpwuid : 사용자 ID를 이용

getpwnam : 사용자 계정을 이용

(-> 함수가 반환하는 값은 정보를 담고있는 struct passwd의 포인터)

getlogin : 사용자 계정을 얻어옴 (getpwnam구현 시 필요)

getpwent : 패스워드 파일로부터 각 사용자에 대한 정보를 처음부터 읽어옴(더이상 없으면 NULL)

setpwent : 패스워드 파일을 열고 시작지점으로 돌아가게 하는 함수(첫 사용자로 돌아가고자 할 때

endpwent : 패스워드 파일에 대한 사용이 끝나면 닫아주는 함수
